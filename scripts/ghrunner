#!/usr/bin/env bash

# GitHub Actions Self-Hosted Runner Manager
# Supports tart (macOS), lima (Linux), and vmware runners

#set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
RUNNER_TYPE=""
RUNNER_NAME=""
SSH_HOST=""
ACTION=""
RUNNER_TOKEN=""
DEBUG_MODE=""

# GitHub repository settings (can be overridden with command line options)
GITHUB_OWNER="${GITHUB_OWNER:-trodemaster}"
GITHUB_REPO="${GITHUB_REPO:-blakeports}"

# Default runner configuration (can be overridden with RUNNER_CONFIG env var)
# JSON format with type, name, ssh_host, and optional labels/description
DEFAULT_RUNNER_CONFIG='[
  {"type":"tart","name":"macOS_15","ssh_host":""},
  {"type":"tart","name":"macOS_26","ssh_host":""},
  {"type":"vmware","name":"tenfive","ssh_host":""},
  {"type":"vmware","name":"tensix","ssh_host":""},
  {"type":"vmware","name":"tenseven","ssh_host":""},
  {"type":"vmware","name":"teneight","ssh_host":""},
  {"type":"vmware","name":"tennine","ssh_host":""},
  {"type":"vmware","name":"tenten","ssh_host":""}
]'
RUNNER_CONFIG="${RUNNER_CONFIG:-$DEFAULT_RUNNER_CONFIG}"

# Tool paths
TART_PATH="/Applications/tart.app/Contents/MacOS/tart"
VMWARE_VMRUN_PATH="/Applications/VMware Fusion.app/Contents/Public/vmrun"
LIMACTL_PATH="/opt/local/bin/limactl"

# VMware configuration
VMWARE_SSH_HOST="darkstar"
VMWARE_BASE_DIR="/Volumes/JonesFarm/actions-runners"
VMWARE_VM_USER="blake"  # SSH user for VMware VMs

# SSH configuration
SSH_OPTS=(
    "-o" "ControlPath ~/.ssh/controlmasters/%r@%h:%p"
    "-o" "ControlMaster auto"
    "-o" "ControlPersist 10m"
    "-o" "StrictHostKeyChecking no"
    "-o" "UserKnownHostsFile=/dev/null"
    "-o" "IdentityAgent /Users/blake/Library/Containers/com.maxgoedjen.Secretive.SecretAgent/Data/socket.ssh"
)

# Legacy SSH configuration for old macOS VMs (10.5-10.10)
# These VMs require openssh9-client with legacy crypto algorithms
LEGACY_SSH_CMD="ssh9"
LEGACY_SSH_KEY="$HOME/.ssh/oldmac"
LEGACY_SSH_OPTS=(
    "-i" "$LEGACY_SSH_KEY"
    "-o" "HostKeyAlgorithms=ssh-rsa"
    "-o" "PubkeyAcceptedKeyTypes=ssh-rsa"
    "-o" "KexAlgorithms=diffie-hellman-group1-sha1"
    "-o" "Ciphers=aes128-cbc"
    "-o" "MACs=hmac-sha1"
    "-o" "StrictHostKeyChecking=no"
    "-o" "Protocol=2"
)

# Function to print usage
usage() {
    cat << EOF
Usage: $0 [OPTIONS]

GitHub Actions Self-Hosted Runner Manager
Creates and manages different types of runners for the current repository.

Options:
    -tart <runner_name>     Create macOS runner using tart VM
    -lima <runner_name>     Create Linux runner using lima VM (stub)
    -vmware <runner_name>   Create VMware runner (stub)
    -ssh <hostname>         Use SSH to connect to remote host
    -owner <github_owner>   Override GitHub owner (default: trodemaster)
    -repo <repo_name>       Override repository name (default: blakeports)
    -list                   List currently registered runners for the repository
    -start-all              Start all configured runners
    -remove-all             Remove/de-register all GitHub runners
    -remove <runner_name>   Remove/de-register a GitHub runner
    -cancel-workflows       Cancel all running workflows
    -debug                  Enable debug mode for SSH connections
    -h, --help              Show this help message

Examples:
    # Create different types of runners for current repo
    $0 -tart macOS_15
    $0 -lima ubuntu-runner
    $0 -vmware tenfive        # Creates runner from runner-tenfive-base on darkstar
    
    # Create runner for specific owner/repo
    $0 -tart macos-runner -owner myusername -repo myproject
    
    # Create runner on remote host
    $0 -tart macos-runner -ssh remote-host
    
    # List current runners
    $0 -list
    $0 -list -owner myusername -repo myproject
    
    # Manage runners
    $0 -start-all
    $0 -remove-all
    $0 -remove macos-runner

Environment Variables:
    GITHUB_OWNER            Set default GitHub owner (default: trodemaster)
    GITHUB_REPO             Set default repository name (default: blakeports)
    RUNNER_CONFIG           JSON configuration for runners used by -start-all
                           Format: [{"type":"tart","name":"vm_name","ssh_host":""},...]
                           Types: tart, lima, vmware
                           ssh_host: empty for local, hostname for remote

Configuration Examples:
    # Local tart runners only
    export RUNNER_CONFIG='[
      {"type":"tart","name":"macOS_15","ssh_host":""},
      {"type":"tart","name":"macOS_26","ssh_host":""}
    ]'
    
    # Mixed local and remote runners
    export RUNNER_CONFIG='[
      {"type":"tart","name":"macOS_15","ssh_host":""},
      {"type":"lima","name":"ubuntu_22","ssh_host":"remote-host"},
      {"type":"vmware","name":"windows_11","ssh_host":"remote-win"}
    ]'

Workflow Usage:
    After creating runners, use them in your workflows:
    
    jobs:
      macos-build:
        runs-on: macos-runner
      
      linux-build:
        runs-on: ubuntu-runner
      
      windows-build:
        runs-on: windows-runner

To setup runners for a different repository:
    1. Use -owner and -repo options: $0 -tart runner-name -owner username -repo reponame
    2. Or set environment variables: GITHUB_OWNER=username GITHUB_REPO=reponame $0 -tart runner-name
    3. Or navigate to that repository directory and run without overrides

EOF
}

# Function to print colored output
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to check if required tools are installed
check_dependencies() {
    local missing_deps=()
    
    # Check for gh CLI
    if ! command -v gh &> /dev/null; then
        missing_deps+=("gh")
    fi
    
    # Check for tart CLI (for macOS runners)
    if [ ! -x "$TART_PATH" ]; then
        missing_deps+=("tart")
    fi
    
    # Check for lima CLI (for Linux runners)
    if [ ! -x "$LIMACTL_PATH" ]; then
        missing_deps+=("lima")
    fi
    
    # Check for vmware vmrun (for VMware runners)
    if [ ! -x "$VMWARE_VMRUN_PATH" ]; then
        missing_deps+=("vmware")
    fi
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        print_error "Missing required dependencies: ${missing_deps[*]}"
        print_info "Please install missing dependencies:"
        for dep in "${missing_deps[@]}"; do
            case $dep in
                "gh")
                    echo "  - GitHub CLI: https://cli.github.com/"
                    ;;
                "tart")
                    echo "  - Tart: https://tart.run/"
                    echo "    Expected path: $TART_PATH"
                    ;;
                "lima")
                    echo "  - Lima: https://lima-vm.io/"
                    echo "    Expected path: $LIMACTL_PATH"
                    ;;
                "vmware")
                    echo "  - VMware Fusion: https://www.vmware.com/products/fusion.html"
                    echo "    Expected path: $VMWARE_VMRUN_PATH"
                    ;;
            esac
        done
        exit 1
    fi
}

# Function to generate GitHub runner token
generate_runner_token() {
    print_info "Generating GitHub runner token..."
    
    if [ -n "$SSH_HOST" ]; then
        print_info "Generating token on remote host: $SSH_HOST"
        # TODO: Implement remote token generation
        print_warning "Remote token generation not yet implemented"
    else
        # Generate token using gh CLI
        if ! gh auth status &> /dev/null; then
            print_error "GitHub CLI not authenticated. Please run 'gh auth login' first."
            exit 1
        fi
        
        print_info "Using repository: $GITHUB_OWNER/$GITHUB_REPO"
        token=$(gh api repos/$GITHUB_OWNER/$GITHUB_REPO/actions/runners/registration-token --method POST --jq '.token' 2>/dev/null)
        if [ $? -ne 0 ] || [ -z "$token" ]; then
            print_error "Failed to generate runner registration token for $GITHUB_OWNER/$GITHUB_REPO. Check your permissions."
            print_info "Make sure you have admin access to the repository or 'Manage runners' permission."
            exit 1
        fi
        # Store token for use in runner setup
        RUNNER_TOKEN="$token"
        print_success "Generated runner registration token for $GITHUB_OWNER/$GITHUB_REPO"
    fi
}

# Function to generate runner labels based on type and architecture
generate_runner_labels() {
    local runner_type=$1
    local os_type=$2
    local arch=$3
    
    local labels="self-hosted"
    
    # Add OS-specific labels
    case "$os_type" in
        "Darwin")
            labels="$labels,macOS"
            ;;
        "Linux")
            labels="$labels,Linux"
            ;;
        *)
            labels="$labels,unknown-os"
            ;;
    esac
    
    # Add runner type label
    labels="$labels,$runner_type"
    
    # Add architecture label
    case "$arch" in
        "x86_64")
            labels="$labels,x64"
            ;;
        "arm64")
            labels="$labels,ARM64"
            ;;
        "aarch64")
            labels="$labels,ARM64"
            ;;
        *)
            labels="$labels,$arch"
            ;;
    esac
    
    echo "$labels"
}

# Function to parse and validate runner configuration
parse_runner_config() {
    local config="$1"
    
    # Validate JSON format
    if ! echo "$config" | jq empty 2>/dev/null; then
        print_error "Invalid JSON format in runner configuration"
        return 1
    fi
    
    # Check if it's an array
    if ! echo "$config" | jq -e 'type == "array"' >/dev/null 2>&1; then
        print_error "Runner configuration must be a JSON array"
        return 1
    fi
    
    # Validate each runner configuration
    local runner_count
    runner_count=$(echo "$config" | jq length)
    
    if [ "$runner_count" -eq 0 ]; then
        print_warning "No runners configured"
        return 0
    fi
    
    for ((i=0; i<runner_count; i++)); do
        local runner_type name ssh_host
        runner_type=$(echo "$config" | jq -r ".[$i].type // empty")
        name=$(echo "$config" | jq -r ".[$i].name // empty")
        ssh_host=$(echo "$config" | jq -r ".[$i].ssh_host // empty")
        
        if [ -z "$runner_type" ] || [ -z "$name" ]; then
            print_error "Runner configuration at index $i missing required fields (type, name)"
            return 1
        fi
        
        # Validate runner type
        case "$runner_type" in
            "tart"|"lima"|"vmware")
                ;;
            *)
                print_error "Invalid runner type '$runner_type' at index $i. Must be: tart, lima, or vmware"
                return 1
                ;;
        esac
    done
    
    return 0
}

# Function to get runner configuration count
get_runner_config_count() {
    local config="$1"
    echo "$config" | jq length 2>/dev/null || echo "0"
}

# Function to get runner configuration at specific index
get_runner_config_at_index() {
    local config="$1"
    local index="$2"
    
    local runner_type name ssh_host labels description
    runner_type=$(echo "$config" | jq -r ".[$index].type // empty")
    name=$(echo "$config" | jq -r ".[$index].name // empty")
    ssh_host=$(echo "$config" | jq -r ".[$index].ssh_host // empty")
    labels=$(echo "$config" | jq -r ".[$index].labels // empty")
    description=$(echo "$config" | jq -r ".[$index].description // empty")
    
    # Return as delimited string for easy parsing
    echo "$runner_type:$name:$ssh_host:$labels:$description"
}

# Function to debug basic connectivity to VM
debug_vm_connectivity() {
    local vm_ip=$1
    
    print_info "=== VM Connectivity Debug ==="
    print_info "VM IP: $vm_ip"
    
    # Test basic ping
    print_info "Testing ping to $vm_ip..."
    if ping -c 3 -W 3000 "$vm_ip" &>/dev/null; then
        print_success "Ping successful"
    else
        print_error "Ping failed - VM may not be reachable"
        return 1
    fi
    
    # Test if SSH port is open
    print_info "Testing SSH port (22) connectivity..."
    if nc -z -w 5 "$vm_ip" 22 2>/dev/null; then
        print_success "SSH port 22 is open"
    else
        print_error "SSH port 22 is not accessible"
        return 1
    fi
    
    # Test SSH with verbose output (first attempt only)
    print_info "Testing SSH with verbose output (first attempt)..."
    local ssh_verbose_output
    ssh_verbose_output=$(ssh -v "${SSH_OPTS[@]}" -o ConnectTimeout=10 admin@"$vm_ip" "echo 'SSH test'" 2>&1)
    local ssh_verbose_exit_code=$?
    
    if [ $ssh_verbose_exit_code -eq 0 ]; then
        print_success "SSH verbose test successful"
    else
        print_error "SSH verbose test failed (exit code: $ssh_verbose_exit_code)"
        print_error "SSH verbose output:"
        echo "$ssh_verbose_output" | head -20 | while IFS= read -r line; do
            print_error "  $line"
        done
    fi
    
    print_info "=== End VM Connectivity Debug ==="
    return 0
}

# Function to test SSH connection with retries
test_ssh_connection_with_retries() {
    local vm_ip=$1
    local use_legacy_ssh=${2:-false}  # Optional parameter for legacy SSH
    local max_attempts=24  # 24 attempts * 5 seconds = 2 minutes
    local attempt=0

    # Determine which SSH command and options to use
    local ssh_cmd="ssh"
    local ssh_user="admin"
    local ssh_opts_array=("${SSH_OPTS[@]}")

    if [ "$use_legacy_ssh" = "true" ]; then
        ssh_cmd="$LEGACY_SSH_CMD"
        ssh_user="$VMWARE_VM_USER"
        ssh_opts_array=("${LEGACY_SSH_OPTS[@]}")
    fi

    print_info "Testing SSH connection to $ssh_user@$vm_ip (will retry for up to 2 minutes)..."
    print_info "Using SSH command: $ssh_cmd"

    # Run connectivity debug first if debug mode is enabled
    if [ "$DEBUG_MODE" = "true" ]; then
        debug_vm_connectivity "$vm_ip"
    fi

    while [ $attempt -lt $max_attempts ]; do
        attempt=$((attempt + 1))

        # Try SSH connection and capture both stdout and stderr for debugging
        local ssh_output
        local ssh_exit_code

        print_info "SSH attempt $attempt/$max_attempts"

        # Capture SSH output for debugging
        ssh_output=$($ssh_cmd "${ssh_opts_array[@]}" -o ConnectTimeout=5 $ssh_user@"$vm_ip" "echo 'SSH connection successful'" 2>&1)
        ssh_exit_code=$?

        if [ $ssh_exit_code -eq 0 ]; then
            print_success "SSH connection established (attempt $attempt/$max_attempts)"
            return 0
        else
            print_warning "SSH attempt $attempt failed (exit code: $ssh_exit_code)"
            if [ -n "$ssh_output" ]; then
                print_error "SSH error details:"
                echo "$ssh_output" | while IFS= read -r line; do
                    print_error "  $line"
                done
            else
                print_error "No SSH error output captured"
            fi
        fi

        if [ $attempt -lt $max_attempts ]; then
            print_info "SSH connection attempt $attempt/$max_attempts failed, retrying in 5 seconds..."
            sleep 5
        fi
    done

    print_error "SSH connection failed after $max_attempts attempts (2 minutes)"
    print_error "Troubleshooting steps:"
    print_error "  1. Verify VM is fully booted"
    print_error "  2. Check if SSH service is running on the VM"
    print_error "  3. Verify the $ssh_user user exists and has SSH access"
    print_error "  4. Try connecting manually: $ssh_cmd $ssh_user@$vm_ip"
    print_error "  5. Check if the VM IP is correct: $vm_ip"
    print_error "  6. Verify SSH key authentication is working"
    return 1
}

# Function to get SSH hostname for a base VM name
get_ssh_hostname() {
    local base_vm_name=$1
    
    # Map base VM names to SSH hostnames (from SSH config)
    case "$base_vm_name" in
        "macOS_26")
            echo "tahoe"
            ;;
        "macOS_15")
            echo "sequoia"
            ;;
        *)
            # Default: use base name as hostname
            echo "$base_vm_name"
            ;;
    esac
}

# Function to detect primary network interface for bridged networking
detect_primary_network_interface() {
    # Try to get the primary network interface
    # On macOS, this is usually en0 (Ethernet) or en1 (Wi-Fi)
    local primary_iface
    
    # Check for active Ethernet interface first
    primary_iface=$(route get default 2>/dev/null | grep interface | awk '{print $2}')
    
    if [ -z "$primary_iface" ]; then
        # Fallback: try to find first active non-loopback interface
        primary_iface=$(ifconfig | grep -E "^[a-z]" | grep -v lo0 | head -1 | cut -d: -f1)
    fi
    
    if [ -z "$primary_iface" ]; then
        # Last resort: use en0 as default
        primary_iface="en0"
        print_warning "Could not detect primary network interface, using default: $primary_iface"
    else
        print_info "Detected primary network interface: $primary_iface"
    fi
    
    echo "$primary_iface"
}

# Function to detect VM architecture and get appropriate runner package
detect_vm_architecture() {
    local vm_ip=$1
    local runner_version=$2
    local use_legacy_ssh=${3:-false}  # Optional parameter for legacy SSH

    # Determine which SSH command and options to use
    local ssh_cmd="ssh"
    local ssh_user="admin"
    local ssh_opts_array=("${SSH_OPTS[@]}")

    if [ "$use_legacy_ssh" = "true" ]; then
        ssh_cmd="$LEGACY_SSH_CMD"
        ssh_user="$VMWARE_VM_USER"
        ssh_opts_array=("${LEGACY_SSH_OPTS[@]}")
    fi

    print_info "Detecting VM architecture..." >&2

    # Get system architecture
    local arch
    arch=$($ssh_cmd "${ssh_opts_array[@]}" $ssh_user@"$vm_ip" "uname -m" 2>/dev/null)
    if [ $? -ne 0 ]; then
        print_error "Failed to detect VM architecture" >&2
        return 1
    fi

    # Get OS type
    local os_type
    os_type=$($ssh_cmd "${ssh_opts_array[@]}" $ssh_user@"$vm_ip" "uname -s" 2>/dev/null)
    if [ $? -ne 0 ]; then
        print_error "Failed to detect VM OS type" >&2
        return 1
    fi

    print_info "Detected OS: $os_type, Architecture: $arch" >&2
    
    # Determine runner package based on OS and architecture
    local runner_package=""
    case "$os_type" in
        "Darwin")
            case "$arch" in
                "x86_64")
                    runner_package="actions-runner-osx-x64-${runner_version}.tar.gz"
                    ;;
                "arm64")
                    runner_package="actions-runner-osx-arm64-${runner_version}.tar.gz"
                    ;;
                *)
                    print_error "Unsupported macOS architecture: $arch" >&2
                    return 1
                    ;;
            esac
            ;;
        "Linux")
            case "$arch" in
                "x86_64")
                    runner_package="actions-runner-linux-x64-${runner_version}.tar.gz"
                    ;;
                "aarch64"|"arm64")
                    runner_package="actions-runner-linux-arm64-${runner_version}.tar.gz"
                    ;;
                *)
                    print_error "Unsupported Linux architecture: $arch" >&2
                    return 1
                    ;;
            esac
            ;;
        *)
            print_error "Unsupported OS type: $os_type" >&2
            return 1
            ;;
    esac
    
    echo "$runner_package"
    return 0
}

# Function to start tart runner (macOS)
start_tart_runner() {
    local base_vm_name=$1
    local runner_vm_name="${base_vm_name}_runner"
    print_info "Starting tart runner: $runner_vm_name (cloned from $base_vm_name)"
    
    if [ -n "$SSH_HOST" ]; then
        print_info "Starting tart runner on remote host: $SSH_HOST"
        # TODO: Implement remote tart runner start
        print_warning "Remote tart runner start not yet implemented"
    else
        # Check if tart is available
        if [ ! -x "$TART_PATH" ]; then
            print_error "Tart CLI not found at: $TART_PATH"
            exit 1
        fi
        
        # Check if base VM exists
        if ! "$TART_PATH" list | grep -q "$base_vm_name"; then
            print_error "Base tart VM '$base_vm_name' not found. Available VMs:"
            "$TART_PATH" list
            exit 1
        fi
        
        # Check if runner VM already exists
        if "$TART_PATH" list | grep -q "$runner_vm_name"; then
            print_info "Runner VM '$runner_vm_name' already exists"
        else
            print_info "Cloning base VM '$base_vm_name' to '$runner_vm_name'..."
            "$TART_PATH" clone "$base_vm_name" "$runner_vm_name"
            if [ $? -ne 0 ]; then
                print_error "Failed to clone VM"
                exit 1
            fi
            print_success "VM cloned successfully"
        fi
        
        # Check if runner VM is already running
        local vm_state
        vm_state=$("$TART_PATH" list | grep "$runner_vm_name" | awk '{print $NF}')
        if [ "$vm_state" = "running" ]; then
            print_warning "Runner VM '$runner_vm_name' is already running"
        else
            print_info "Starting runner VM: $runner_vm_name"
            # Use bridged networking on en0 interface
            print_info "Using bridged networking on interface: en0"
            # Start VM in background with graphics and bridged networking
            "$TART_PATH" run --net-bridged en0 "$runner_vm_name" &
            local vm_pid=$!
            
            # Wait for VM to boot and initialize networking
            print_info "Waiting for VM to boot and initialize networking (45 seconds)..."
            sleep 45
            
            # Get VM connection info - prefer SSH hostname, fall back to tart ip
            print_info "Getting VM connection info..."
            local vm_ip
            local ssh_hostname
            ssh_hostname=$(get_ssh_hostname "$base_vm_name")
            
            # Try SSH hostname first with periodic retries for up to 1 minute
            print_info "Trying SSH hostname: $ssh_hostname (will retry for up to 1 minute while VM boots)..."
            local ssh_attempts=0
            local ssh_max_attempts=12  # 12 attempts * 5 seconds = 60 seconds
            local ssh_success=false
            
            while [ $ssh_attempts -lt $ssh_max_attempts ]; do
                ssh_attempts=$((ssh_attempts + 1))
                if ssh "${SSH_OPTS[@]}" -o ConnectTimeout=5 admin@"$ssh_hostname" "echo 'SSH test'" &>/dev/null; then
                    print_success "SSH hostname is reachable: $ssh_hostname (after $((ssh_attempts * 5)) seconds)"
                    vm_ip="$ssh_hostname"
                    ssh_success=true
                    break
                else
                    if [ $ssh_attempts -lt $ssh_max_attempts ]; then
                        print_info "SSH hostname not yet reachable (attempt $ssh_attempts/$ssh_max_attempts), retrying in 5 seconds..."
                        sleep 5
                    fi
                fi
            done
            
            # If SSH hostname didn't work after 1 minute, fall back to tart ip
            if [ "$ssh_success" = false ]; then
                print_warning "SSH hostname not reachable after 1 minute, trying tart ip..."
                local attempts=0
                while [ $attempts -lt 30 ]; do
                    vm_ip=$("$TART_PATH" ip --wait 5 "$runner_vm_name" 2>/dev/null)
                    if [ $? -eq 0 ] && [ -n "$vm_ip" ] && [ "$vm_ip" != "null" ]; then
                        print_success "VM IP (from tart): $vm_ip"
                        break
                    fi
                    attempts=$((attempts + 1))
                    sleep 2
                done
                
                # If tart ip also failed, use SSH hostname anyway (might work after VM fully boots)
                if [ -z "$vm_ip" ] || [ "$vm_ip" = "null" ]; then
                    print_warning "Failed to get VM IP address via tart ip after $((attempts * 2)) seconds"
                    print_info "Using SSH hostname as final fallback: $ssh_hostname"
                    vm_ip="$ssh_hostname"
                fi
            fi
        fi
        
        # Get VM IP if not already running
        if [ -z "$vm_ip" ]; then
            local ssh_hostname
            ssh_hostname=$(get_ssh_hostname "$base_vm_name")
            
            # Try SSH hostname first with periodic retries for up to 1 minute
            print_info "Trying SSH hostname: $ssh_hostname (will retry for up to 1 minute)..."
            local ssh_attempts=0
            local ssh_max_attempts=12  # 12 attempts * 5 seconds = 60 seconds
            local ssh_success=false
            
            while [ $ssh_attempts -lt $ssh_max_attempts ]; do
                ssh_attempts=$((ssh_attempts + 1))
                if ssh "${SSH_OPTS[@]}" -o ConnectTimeout=5 admin@"$ssh_hostname" "echo 'SSH test'" &>/dev/null; then
                    print_success "SSH hostname is reachable: $ssh_hostname (after $((ssh_attempts * 5)) seconds)"
                    vm_ip="$ssh_hostname"
                    ssh_success=true
                    break
                else
                    if [ $ssh_attempts -lt $ssh_max_attempts ]; then
                        print_info "SSH hostname not yet reachable (attempt $ssh_attempts/$ssh_max_attempts), retrying in 5 seconds..."
                        sleep 5
                    fi
                fi
            done
            
            # If SSH hostname didn't work after 1 minute, fall back to tart ip
            if [ "$ssh_success" = false ]; then
                print_warning "SSH hostname not reachable after 1 minute, trying tart ip..."
                vm_ip=$("$TART_PATH" ip "$runner_vm_name" 2>/dev/null)
                if [ $? -eq 0 ] && [ -n "$vm_ip" ] && [ "$vm_ip" != "null" ]; then
                    print_success "VM IP (from tart): $vm_ip"
                else
                    print_warning "Failed to get VM IP address via tart ip"
                    print_info "Using SSH hostname as final fallback: $ssh_hostname"
                    vm_ip="$ssh_hostname"
                fi
            fi
        fi
        
        # Wait for SSH to be available with retries
        if ! test_ssh_connection_with_retries "$vm_ip"; then
            print_error "Failed to establish SSH connection to VM after all retry attempts"
            print_error "This usually indicates one of the following issues:"
            print_error "  1. VM is not fully booted or SSH service is not running"
            print_error "  2. Network connectivity issues between host and VM"
            print_error "  3. SSH authentication problems (key not found or incorrect)"
            print_error "  4. VM IP address is incorrect or VM is not accessible"
            print_error ""
            print_error "Try running with -debug flag for more detailed information:"
            print_error "  $0 -tart $base_vm_name -debug"
            exit 1
        fi
        
        # Install and configure GitHub runner
        print_info "Installing GitHub runner on VM..."
        
        # get lastest stable runner version
        local runner_version=$(curl -s https://api.github.com/repos/actions/runner/releases/latest | jq -r '.tag_name' | sed 's/v//')

        # Download runner to VM
        
        # Detect VM architecture and get appropriate runner package
        local runner_package
        runner_package=$(detect_vm_architecture "$vm_ip" "$runner_version")
        if [ $? -ne 0 ]; then
            print_error "Failed to determine runner package for VM"
            exit 1
        fi
        
        # Get OS and architecture info for labels
        local vm_os_type=$(ssh "${SSH_OPTS[@]}" admin@"$vm_ip" "uname -s" 2>/dev/null)
        local vm_arch=$(ssh "${SSH_OPTS[@]}" admin@"$vm_ip" "uname -m" 2>/dev/null)
        local runner_labels=$(generate_runner_labels "tart" "$vm_os_type" "$vm_arch")
        # Add the base_vm_name as a custom label for matrix targeting
        runner_labels="$runner_labels,$base_vm_name"
        
        local runner_url="https://github.com/actions/runner/releases/download/v${runner_version}/${runner_package}"
        print_info "Using runner package: $runner_package"
        print_info "Runner labels: $runner_labels"
        
        # Execute commands in VM to set up runner
        print_info "Downloading GitHub runner..."
        ssh "${SSH_OPTS[@]}" admin@"$vm_ip" "curl -o /tmp/actions-runner.tar.gz -L '$runner_url'"
        if [ $? -ne 0 ]; then
            print_error "Failed to download GitHub runner"
            exit 1
        fi
        
        print_info "Extracting runner..."
        ssh "${SSH_OPTS[@]}" admin@"$vm_ip" "sudo mkdir -p /opt/actions-runner && sudo tar -xzf /tmp/actions-runner.tar.gz -C /opt/actions-runner && sudo chown -R admin:admin /opt/actions-runner && rm /tmp/actions-runner.tar.gz"
        
        print_info "Configuring runner..."
        # Configure the runner with the token - use the original name for the runner registration
        ssh "${SSH_OPTS[@]}" admin@"$vm_ip" "cd /opt/actions-runner && ./config.sh --url 'https://github.com/$GITHUB_OWNER/$GITHUB_REPO' --token '$RUNNER_TOKEN' --name '$base_vm_name' --labels '$runner_labels' --unattended --replace"
        
        if [ $? -ne 0 ]; then
            print_error "Failed to configure GitHub runner"
            exit 1
        fi
        
        # Install and start service for the primary instance
        print_info "Installing runner service..."
        ssh "${SSH_OPTS[@]}" admin@"$vm_ip" "cd /opt/actions-runner && ./svc.sh install"
        if [ $? -ne 0 ]; then
            print_error "Failed to install runner service"
            exit 1
        fi
        
        print_info "Starting runner service..."
        ssh "${SSH_OPTS[@]}" admin@"$vm_ip" "cd /opt/actions-runner && ./svc.sh start"
        if [ $? -ne 0 ]; then
            print_error "Failed to start runner service"
            exit 1
        fi
        
        print_success "GitHub runner '$base_vm_name' is now running on cloned VM '$runner_vm_name' (IP: $vm_ip)"
        print_info "Runner service status:"
        ssh "${SSH_OPTS[@]}" admin@"$vm_ip" "cd /opt/actions-runner && ./svc.sh status"
    fi
}

# Function to start lima runner (Linux) - stub
start_lima_runner() {
    local runner_name=$1
    print_info "Starting lima runner: $runner_name (stub implementation)"
    
    if [ -n "$SSH_HOST" ]; then
        print_info "Starting lima runner on remote host: $SSH_HOST"
        # TODO: Implement remote lima runner start
        print_warning "Remote lima runner start not yet implemented"
    else
        # Check if lima is available
        if [ ! -x "$LIMACTL_PATH" ]; then
            print_error "Lima CLI not found at: $LIMACTL_PATH"
            exit 1
        fi
        
        # Stub implementation
        print_warning "Lima runner start is a stub - implement actual logic for $runner_name"
        print_info "Using limactl path: $LIMACTL_PATH"
        print_info "This would typically involve:"
        print_info "  1. Starting lima VM with specific configuration"
        print_info "  2. Installing GitHub runner on the VM"
        print_info "  3. Configuring and starting the runner service"
    fi
}

# Function to get VMware VM path on remote host
get_vmware_vm_path() {
    local vm_name=$1
    echo "$VMWARE_BASE_DIR/${vm_name}.vmwarevm/${vm_name}.vmx"
}

# Function to get VMware base VM path
get_vmware_base_vm_path() {
    local base_name=$1
    echo "$VMWARE_BASE_DIR/runner-${base_name}-base.vmwarevm/runner-${base_name}-base.vmx"
}

# Function to check if VMware VM exists on remote host
vmware_vm_exists() {
    local vm_name=$1
    local vm_path=$(get_vmware_vm_path "$vm_name")

    if ssh "$VMWARE_SSH_HOST" "test -f '$vm_path'"; then
        return 0
    else
        return 1
    fi
}

# Function to get VMware VM hostname
get_vmware_vm_hostname() {
    local base_vm_name=$1
    # Legacy VMs use predictable hostnames: {version}-runner.local
    echo "${base_vm_name}-runner.local"
}

# Function to start vmware runner
start_vmware_runner() {
    local base_vm_name=$1
    local runner_vm_name="runner-${base_vm_name}"
    local base_vm_path=$(get_vmware_base_vm_path "$base_vm_name")
    local runner_vm_path=$(get_vmware_vm_path "$runner_vm_name")

    print_info "Starting VMware runner: $runner_vm_name (from base: runner-${base_vm_name}-base)"
    print_info "Remote VMware host: $VMWARE_SSH_HOST"
    print_info "Base VM path: $base_vm_path"
    print_info "Runner VM path: $runner_vm_path"

    # Check if base VM exists
    if ! ssh "$VMWARE_SSH_HOST" "test -f '$base_vm_path'"; then
        print_error "Base VMware VM not found: $base_vm_path"
        print_info "Available VMs in $VMWARE_BASE_DIR:"
        ssh "$VMWARE_SSH_HOST" "ls -1 '$VMWARE_BASE_DIR' | grep -E '\.vmwarevm$'"
        exit 1
    fi

    # Track if VM was already running (to skip boot wait)
    local vm_already_running=false

    # Check if runner VM already exists
    if vmware_vm_exists "$runner_vm_name"; then
        print_info "Runner VM '$runner_vm_name' already exists"

        # Check if it's already running
        local running_vms
        running_vms=$(ssh "$VMWARE_SSH_HOST" "'$VMWARE_VMRUN_PATH' list" 2>/dev/null)

        if echo "$running_vms" | grep -q "$runner_vm_path"; then
            print_warning "Runner VM '$runner_vm_name' is already running"
            vm_already_running=true
        else
            print_info "Starting existing runner VM: $runner_vm_name"
            ssh "$VMWARE_SSH_HOST" "'$VMWARE_VMRUN_PATH' start '$runner_vm_path' nogui"
            if [ $? -ne 0 ]; then
                print_error "Failed to start VM"
                exit 1
            fi
            print_success "VM started successfully"
        fi
    else
        print_info "Creating linked clone: $runner_vm_name from runner-${base_vm_name}-base"

        # Create the directory for the clone
        ssh "$VMWARE_SSH_HOST" "mkdir -p '${VMWARE_BASE_DIR}/${runner_vm_name}.vmwarevm'"

        # Clone the VM (linked clone for efficiency)
        # Linked clones don't require explicit snapshots - vmrun handles it
        print_info "Cloning VM (this may take a moment)..."
        ssh "$VMWARE_SSH_HOST" "'$VMWARE_VMRUN_PATH' clone '$base_vm_path' '$runner_vm_path' linked -cloneName='$runner_vm_name'"

        if [ $? -ne 0 ]; then
            print_error "Failed to clone VM"
            exit 1
        fi
        print_success "VM cloned successfully"

        print_info "Starting runner VM: $runner_vm_name"
        ssh "$VMWARE_SSH_HOST" "'$VMWARE_VMRUN_PATH' start '$runner_vm_path' nogui"

        if [ $? -ne 0 ]; then
            print_error "Failed to start VM"
            exit 1
        fi
        print_success "VM started successfully"
    fi

    # Wait for VM to boot (only if we just started it)
    if [ "$vm_already_running" = false ]; then
        print_info "Waiting for VM to boot (30 seconds)..."
        sleep 30
    else
        print_info "Skipping boot wait (VM was already running)"
    fi

    # Get VM hostname (predictable: {version}-runner.local)
    local vm_hostname
    vm_hostname=$(get_vmware_vm_hostname "$base_vm_name")
    print_info "Using VM hostname: $vm_hostname"

    # Wait for SSH to be available with retries (using legacy SSH)
    if ! test_ssh_connection_with_retries "$vm_hostname" true; then
        print_error "Failed to establish SSH connection to VM after all retry attempts"
        exit 1
    fi

    # Install and configure GitHub runner
    print_info "Installing GitHub runner on VM..."

    # Get latest stable runner version
    local runner_version=$(curl -s https://api.github.com/repos/actions/runner/releases/latest | jq -r '.tag_name' | sed 's/v//')

    # Detect VM architecture and get appropriate runner package (using legacy SSH)
    local runner_package
    runner_package=$(detect_vm_architecture "$vm_hostname" "$runner_version" true)
    if [ $? -ne 0 ]; then
        print_error "Failed to determine runner package for VM"
        exit 1
    fi

    # Get OS and architecture info for labels
    local vm_os_type=$($LEGACY_SSH_CMD "${LEGACY_SSH_OPTS[@]}" $VMWARE_VM_USER@"$vm_hostname" "uname -s" 2>/dev/null)
    local vm_arch=$($LEGACY_SSH_CMD "${LEGACY_SSH_OPTS[@]}" $VMWARE_VM_USER@"$vm_hostname" "uname -m" 2>/dev/null)
    local runner_labels=$(generate_runner_labels "vmware" "$vm_os_type" "$vm_arch")
    # Add the base_vm_name as a custom label for matrix targeting
    runner_labels="$runner_labels,$base_vm_name"

    local runner_url="https://github.com/actions/runner/releases/download/v${runner_version}/${runner_package}"
    print_info "Using runner package: $runner_package"
    print_info "Runner labels: $runner_labels"

    # Execute commands in VM to set up runner
    print_info "Downloading GitHub runner..."
    $LEGACY_SSH_CMD "${LEGACY_SSH_OPTS[@]}" $VMWARE_VM_USER@"$vm_hostname" "curl -o /tmp/actions-runner.tar.gz -L '$runner_url'"
    if [ $? -ne 0 ]; then
        print_error "Failed to download GitHub runner"
        exit 1
    fi

    print_info "Extracting runner..."
    $LEGACY_SSH_CMD "${LEGACY_SSH_OPTS[@]}" $VMWARE_VM_USER@"$vm_hostname" "sudo mkdir -p /opt/actions-runner && sudo tar -xzf /tmp/actions-runner.tar.gz -C /opt/actions-runner && sudo chown -R $VMWARE_VM_USER:staff /opt/actions-runner && rm /tmp/actions-runner.tar.gz"

    print_info "Configuring runner..."
    # Configure the runner with the token - use the original name for the runner registration
    $LEGACY_SSH_CMD "${LEGACY_SSH_OPTS[@]}" $VMWARE_VM_USER@"$vm_hostname" "cd /opt/actions-runner && ./config.sh --url 'https://github.com/$GITHUB_OWNER/$GITHUB_REPO' --token '$RUNNER_TOKEN' --name '$base_vm_name' --labels '$runner_labels' --unattended --replace"

    if [ $? -ne 0 ]; then
        print_error "Failed to configure GitHub runner"
        exit 1
    fi

    # Install and start service
    print_info "Installing runner service..."
    $LEGACY_SSH_CMD "${LEGACY_SSH_OPTS[@]}" $VMWARE_VM_USER@"$vm_hostname" "cd /opt/actions-runner && ./svc.sh install"
    if [ $? -ne 0 ]; then
        print_error "Failed to install runner service"
        exit 1
    fi

    print_info "Starting runner service..."
    $LEGACY_SSH_CMD "${LEGACY_SSH_OPTS[@]}" $VMWARE_VM_USER@"$vm_hostname" "cd /opt/actions-runner && ./svc.sh start"
    if [ $? -ne 0 ]; then
        print_error "Failed to start runner service"
        exit 1
    fi

    print_success "GitHub runner '$base_vm_name' is now running on VMware VM '$runner_vm_name' (hostname: $vm_hostname)"
    print_info "Runner service status:"
    $LEGACY_SSH_CMD "${LEGACY_SSH_OPTS[@]}" $VMWARE_VM_USER@"$vm_hostname" "cd /opt/actions-runner && ./svc.sh status"
}

# Helper function to start a single runner (for parallel execution)
start_single_runner_parallel() {
    local runner_type="$1"
    local name="$2"
    local ssh_host="$3"
    local runner_token="$4"
    local index="$5"
    local temp_dir="$6"
    
    # Create result file for this runner
    local result_file="$temp_dir/runner_$index.result"
    local log_file="$temp_dir/runner_$index.log"
    
    # Set up environment for this runner
    local original_ssh_host="$SSH_HOST"
    if [ -n "$ssh_host" ]; then
        SSH_HOST="$ssh_host"
    fi
    
    # Use the shared token
    RUNNER_TOKEN="$runner_token"
    
    # Redirect output to log file and capture result
    exec > "$log_file" 2>&1
    
    print_info "Starting runner $((index+1)): $name ($runner_type)"
    if [ -n "$ssh_host" ]; then
        print_info "Using SSH host: $ssh_host"
    fi
    
    # Start the runner based on type
    case "$runner_type" in
        "tart")
            if start_tart_runner "$name"; then
                echo "SUCCESS:$name:$runner_type" > "$result_file"
                print_success "Successfully started tart runner: $name"
            else
                echo "FAILURE:$name:$runner_type" > "$result_file"
                print_error "Failed to start tart runner: $name"
            fi
            ;;
        "lima")
            if start_lima_runner "$name"; then
                echo "SUCCESS:$name:$runner_type" > "$result_file"
                print_success "Successfully started lima runner: $name"
            else
                echo "FAILURE:$name:$runner_type" > "$result_file"
                print_error "Failed to start lima runner: $name"
            fi
            ;;
        "vmware")
            if start_vmware_runner "$name"; then
                echo "SUCCESS:$name:$runner_type" > "$result_file"
                print_success "Successfully started vmware runner: $name"
            else
                echo "FAILURE:$name:$runner_type" > "$result_file"
                print_error "Failed to start vmware runner: $name"
            fi
            ;;
        *)
            echo "FAILURE:$name:$runner_type:Unknown runner type" > "$result_file"
            print_error "Unknown runner type: $runner_type"
            ;;
    esac
    
    # Restore original SSH_HOST
    SSH_HOST="$original_ssh_host"
}

# Function to start all runners
start_all_runners() {
    print_info "Starting all configured runners..."
    
    # Parse and validate configuration
    if ! parse_runner_config "$RUNNER_CONFIG"; then
        print_error "Failed to parse runner configuration"
        exit 1
    fi
    
    local runner_count
    runner_count=$(get_runner_config_count "$RUNNER_CONFIG")
    
    if [ "$runner_count" -eq 0 ]; then
        print_warning "No runners configured to start"
        return 0
    fi
    
    print_info "Found $runner_count configured runner(s)"
    
    # Generate GitHub token once for all runners
    generate_runner_token
    
    # Create temporary directory for parallel execution results
    local temp_dir=$(mktemp -d)
    local pids=()
    
    print_info "Starting all runners in parallel..."
    
    # Start each configured runner in parallel
    for ((i=0; i<runner_count; i++)); do
        local runner_config runner_type name ssh_host labels description
        runner_config=$(get_runner_config_at_index "$RUNNER_CONFIG" "$i")
        
        # Parse the configuration
        IFS=':' read -r runner_type name ssh_host labels description <<< "$runner_config"
        
        print_info "Initiating parallel start for runner $((i+1))/$runner_count: $name ($runner_type)"
        
        # Start runner in background
        start_single_runner_parallel "$runner_type" "$name" "$ssh_host" "$RUNNER_TOKEN" "$i" "$temp_dir" &
        pids+=($!)
    done
    
    print_info "All runners initiated. Waiting for completion..."
    
    # Wait for all background processes to complete
    local completed=0
    local total=${#pids[@]}
    
    for pid in "${pids[@]}"; do
        if wait "$pid"; then
            completed=$((completed + 1))
            print_info "Runner process completed ($completed/$total)"
        else
            print_warning "Runner process failed ($completed/$total)"
        fi
    done
    
    # Collect and display results
    local success_count=0
    local failure_count=0
    
    echo
    print_info "Parallel execution completed. Processing results..."
    echo
    
    # Display logs in order and count results
    for ((i=0; i<runner_count; i++)); do
        local result_file="$temp_dir/runner_$i.result"
        local log_file="$temp_dir/runner_$i.log"
        
        # Display the log output
        if [ -f "$log_file" ]; then
            cat "$log_file"
        fi
        
        # Process the result
        if [ -f "$result_file" ]; then
            local result=$(cat "$result_file")
            if [[ "$result" == SUCCESS:* ]]; then
                success_count=$((success_count + 1))
            else
                failure_count=$((failure_count + 1))
            fi
        else
            failure_count=$((failure_count + 1))
            print_error "No result file found for runner $((i+1))"
        fi
        
        # Add separator between runners (except for the last one)
        if [ $((i + 1)) -lt "$runner_count" ]; then
            echo
        fi
    done
    
    # Clean up temporary directory
    rm -rf "$temp_dir"
    
    # Print summary
    echo
    print_info "Runner startup summary:"
    print_success "Successfully started: $success_count"
    if [ "$failure_count" -gt 0 ]; then
        print_error "Failed to start: $failure_count"
    fi
    
    if [ "$success_count" -eq "$runner_count" ]; then
        print_success "All configured runners started successfully!"
    elif [ "$success_count" -eq 0 ]; then
        print_error "No runners were started successfully"
        return 1
    else
        print_warning "Some runners failed to start"
        return 1
    fi
}

# Function to stop all running workflows
stop_all_workflows() {
    print_info "Stopping all running workflows..."
    
    # Generate GitHub token to ensure we have auth and repo context
    generate_runner_token
    
    # Get list of in-progress workflow runs (try multiple statuses)
    local running_runs
    running_runs=$(gh run list --status in_progress,queued,waiting --json databaseId,id,workflowName,status --limit 100 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        print_error "Failed to fetch running workflows for $GITHUB_OWNER/$GITHUB_REPO"
        return 1
    fi
    
    local run_count
    run_count=$(echo "$running_runs" | jq 'length' 2>/dev/null)
    
    if [ "$run_count" = "0" ] || [ -z "$run_count" ]; then
        print_info "No running workflows found"
        return 0
    fi
    
    print_info "Found $run_count workflow(s) to stop (in_progress, queued, waiting)"
    
    # Stop each running workflow
    local stopped_count=0
    while IFS='|' read -r run_id workflow_id workflow_name; do
        if [ -n "$run_id" ] && [ -n "$workflow_id" ]; then
            print_info "Stopping workflow '$workflow_name' (ID: $workflow_id)..."
            
            # Cancel the workflow run
            if gh run cancel "$workflow_id" 2>/dev/null; then
                print_success "Successfully stopped workflow '$workflow_name'"
                stopped_count=$((stopped_count + 1))
            else
                print_warning "Failed to stop workflow '$workflow_name'"
            fi
        fi
    done < <(echo "$running_runs" | jq -r '.[] | "\(.databaseId)|\(.id)|\(.workflowName)"')
    
    print_success "Stopped $stopped_count workflow(s)"
    
    # Wait a moment for workflows to fully stop
    if [ "$stopped_count" -gt 0 ]; then
        print_info "Waiting for workflows to fully stop..."
        sleep 5
    fi
}

# Function to remove all VMware runners
remove_all_vmware_runners() {
    print_info "Discovering and removing VMware runner VMs on $VMWARE_SSH_HOST..."

    # Get list of all VMs that start with "runner-" but NOT the base templates (which end with "-base")
    local runner_vms
    runner_vms=$(ssh "$VMWARE_SSH_HOST" "ls -1 '$VMWARE_BASE_DIR' | grep -E '^runner-' | grep -v '\-base\.vmwarevm$' | grep '\.vmwarevm$' | sed 's/\.vmwarevm$//'")

    if [ -z "$runner_vms" ]; then
        print_info "No VMware runner VMs found"
        return 0
    fi

    print_info "Found runner VMs to process:"
    echo "$runner_vms" | while read -r vm; do echo "  - $vm"; done

    local runner_count=0
    local removed_count=0

    # Process each runner VM
    while IFS= read -r vm_name; do
        if [ -z "$vm_name" ]; then
            continue
        fi

        runner_count=$((runner_count + 1))

        print_info "Processing runner VM $runner_count: $vm_name"

        # Safety check: Never delete template VMs (those with -base suffix)
        if [[ "$vm_name" == *"-base" ]]; then
            print_error "SAFETY CHECK FAILED: Attempted to delete template VM '$vm_name'"
            print_error "Template VMs should never be deleted. Skipping to prevent data loss."
            continue
        fi

        local vm_path=$(get_vmware_vm_path "$vm_name")

        # Check if VM is running
        local running_vms
        running_vms=$(ssh "$VMWARE_SSH_HOST" "'$VMWARE_VMRUN_PATH' list" 2>/dev/null)

        if echo "$running_vms" | grep -q "$vm_path"; then
            print_info "VM '$vm_name' is running - stopping it..."
            ssh "$VMWARE_SSH_HOST" "'$VMWARE_VMRUN_PATH' stop '$vm_path' hard" 2>/dev/null || print_warning "Failed to stop VM (may already be stopped)"
            sleep 2
        fi

        # Delete the VM
        print_info "Deleting VMware VM: $vm_name"
        if ssh "$VMWARE_SSH_HOST" "'$VMWARE_VMRUN_PATH' deleteVM '$vm_path'" 2>/dev/null; then
            print_success "Deleted VM: $vm_name"
            removed_count=$((removed_count + 1))
        else
            # Try alternative: just remove the directory
            print_warning "vmrun deleteVM failed, trying direct directory removal..."
            if ssh "$VMWARE_SSH_HOST" "rm -rf '${VMWARE_BASE_DIR}/${vm_name}.vmwarevm'"; then
                print_success "Removed VM directory: $vm_name"
                removed_count=$((removed_count + 1))
            else
                print_error "Failed to delete VM: $vm_name (but continuing with other VMs)"
            fi
        fi

        echo "---" # Separator between VMs

    done <<< "$runner_vms"

    print_success "Processed $runner_count VMware runner VMs, removed $removed_count VMs"

    if [ "$removed_count" -gt 0 ]; then
        print_info "Base VMs remain available for future runner creation"
    fi
}

# Function to remove all runners
remove_all_runners() {
    print_info "Removing all GitHub runners using GitHub API..."

    # Remove all tart VMs (local cleanup only)
    remove_all_tart_runners

    # Remove all VMware VMs (remote cleanup)
    remove_all_vmware_runners

    # Remove all runners from GitHub via API
    while :; do
        local runners
        local gh_cmd="gh api repos/$GITHUB_OWNER/$GITHUB_REPO/actions/runners --jq '.runners[] | @base64'"
        runners=$(eval $gh_cmd 2>/dev/null)
        if [ $? -ne 0 ]; then
            print_error "Failed to fetch runners from GitHub API. Aborting runner removal."
            print_info "Command attempted: $gh_cmd"
            return 1
        fi
        if [ -z "$runners" ]; then
            print_success "No runners found in GitHub API. All runners removed."
            break
        fi

        echo "$runners" | while read -r runner; do
            [ -z "$runner" ] && continue
            _jq() { echo "$runner" | base64 --decode | jq -r "$1"; }
            id=$(_jq '.id')
            name=$(_jq '.name')
            status=$(_jq '.status')
            if [ -n "$id" ]; then
                print_info "Removing runner '$name' (ID: $id, Status: $status)..."
                gh api repos/$GITHUB_OWNER/$GITHUB_REPO/actions/runners/$id --method DELETE || print_error "Failed to delete runner $name (ID: $id)"
                sleep 1
            fi
        done

        sleep 2
    done
}

# Function to remove all tart runners
remove_all_tart_runners() {
    print_info "Discovering and removing tart runner VMs..."
    
    # Check if tart is available
    if [ ! -x "$TART_PATH" ]; then
        print_warning "Tart CLI not found at: $TART_PATH - skipping tart runners"
        return 0
    fi
    
    # Get list of all VMs that end with "_runner" (these are the runner VMs, NOT the template VMs)
    local runner_vms
    runner_vms=$("$TART_PATH" list | grep "_runner" | awk '{print $2}')
    
    if [ -z "$runner_vms" ]; then
        print_info "No tart runner VMs found"
        # Still need to clean up GitHub registrations even if no VMs exist
        print_info "Cleaning up GitHub runner registrations..."
        remove_runners_from_github_api
        return 0
    fi
    
    print_info "Found runner VMs to process:"
    echo "$runner_vms" | while read -r vm; do echo "  - $vm"; done
    
    local runner_count=0
    local removed_count=0
    
    # Process each runner VM
    while IFS= read -r vm_name; do
        if [ -z "$vm_name" ]; then
            continue
        fi
        
        runner_count=$((runner_count + 1))
        
        # Extract base name by removing "_runner" suffix
        local base_name="${vm_name%_runner}"
        print_info "Processing runner VM $runner_count: $vm_name (base: $base_name)"
        
        # Safety check: Never delete template VMs (those without _runner suffix)
        if [ "$vm_name" = "$base_name" ]; then
            print_error "SAFETY CHECK FAILED: Attempted to delete template VM '$vm_name'"
            print_error "Template VMs should never be deleted. Only runner VMs with '_runner' suffix should be removed."
            print_error "Skipping this VM to prevent data loss."
            continue
        fi
        
        # Get VM state - use more robust grep
        local vm_state
        vm_state=$("$TART_PATH" list | awk -v vm="$vm_name" '$2 == vm {print $NF}')
        
        # Get VM IP if running
        local vm_ip=""
        if [ "$vm_state" = "running" ]; then
            vm_ip=$("$TART_PATH" ip "$vm_name" 2>/dev/null || echo "")
        fi
        
        # Skip SSH cleanup - just proceed with VM cleanup
        if [ -n "$vm_ip" ] && [ "$vm_ip" != "null" ]; then
            print_info "VM '$vm_name' is running (IP: $vm_ip) - skipping SSH cleanup, will rely on GitHub API"
        elif [ "$vm_state" = "running" ]; then
            print_info "VM '$vm_name' is running but IP is unavailable - proceeding with VM cleanup"
        else
            print_info "VM '$vm_name' is $vm_state - proceeding with VM cleanup"
        fi
        
        # Stop the VM (don't exit on failure)
        print_info "Stopping tart VM: $vm_name"
        if ! "$TART_PATH" stop "$vm_name" 2>/dev/null; then
            print_warning "VM may already be stopped or failed to stop"
        fi
        
        # Delete the VM (don't exit on failure)
        print_info "Deleting tart VM: $vm_name"
        if "$TART_PATH" delete "$vm_name" 2>/dev/null; then
            print_success "Deleted VM: $vm_name"
            removed_count=$((removed_count + 1))
        else
            print_error "Failed to delete VM: $vm_name (but continuing with other VMs)"
        fi
        
        echo "---" # Separator between VMs
        
    done <<< "$runner_vms"
    
    print_success "Processed $runner_count tart runner VMs, removed $removed_count VMs"
    
    # Always attempt to remove runners from GitHub API as a cleanup step
    print_info "Cleaning up GitHub runner registrations..."
    remove_runners_from_github_api
    
    if [ "$removed_count" -gt 0 ]; then
        print_info "Base VMs remain available for future runner creation"
    fi
}

# Function to remove runners directly from GitHub API
remove_runners_from_github_api() {
    print_info "Removing runners directly from GitHub API..."
    
    # Get list of registered runners
    local runners_json
    runners_json=$(gh api repos/$GITHUB_OWNER/$GITHUB_REPO/actions/runners --jq '.runners' 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        print_error "Failed to fetch runners from GitHub API"
        return 1
    fi
    
    local runner_count
    runner_count=$(echo "$runners_json" | jq 'length' 2>/dev/null)
    
    if [ "$runner_count" = "0" ] || [ -z "$runner_count" ]; then
        print_info "No runners found in GitHub API"
        return 0
    fi
    
    print_info "Found $runner_count runner(s) to remove from GitHub API"
    
    # Remove each runner
    local removed_count=0
    while IFS='|' read -r runner_id runner_name; do
        if [ -n "$runner_id" ] && [ -n "$runner_name" ]; then
            print_info "Removing runner '$runner_name' (ID: $runner_id) from GitHub API..."
            
            # Remove runner using GitHub API
            if gh api repos/$GITHUB_OWNER/$GITHUB_REPO/actions/runners/$runner_id --method DELETE 2>/dev/null; then
                print_success "Successfully removed runner '$runner_name' from GitHub API"
                removed_count=$((removed_count + 1))
            else
                print_warning "Failed to remove runner '$runner_name' from GitHub API"
            fi
        fi
    done < <(echo "$runners_json" | jq -r '.[] | "\(.id)|\(.name)"')
    
    print_success "Removed $removed_count runner(s) from GitHub API"
    
    # Wait and verify that runners are actually removed
    if [ "$removed_count" -gt 0 ]; then
        wait_for_runners_removal
    fi
}

# Function to wait and verify that runners are removed from GitHub
wait_for_runners_removal() {
    print_info "Waiting for runners to be removed from GitHub..."
    
    local max_attempts=30  # 30 attempts * 2 seconds = 60 seconds max wait
    local attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        attempt=$((attempt + 1))
        
        # Check if any runners still exist
        local remaining_runners
        remaining_runners=$(gh api repos/$GITHUB_OWNER/$GITHUB_REPO/actions/runners --jq '.runners | length' 2>/dev/null)
        
        if [ $? -ne 0 ]; then
            print_warning "Failed to check remaining runners (attempt $attempt/$max_attempts)"
            sleep 2
            continue
        fi
        
        if [ "$remaining_runners" = "0" ] || [ -z "$remaining_runners" ]; then
            print_success "All runners successfully removed from GitHub (confirmed after $((attempt * 2)) seconds)"
            return 0
        else
            print_info "Still waiting for $remaining_runners runner(s) to be removed... (attempt $attempt/$max_attempts)"
            sleep 2
        fi
    done
    
    print_warning "Timeout waiting for runners to be removed from GitHub after $((max_attempts * 2)) seconds"
    print_info "Some runners may still appear in the GitHub web UI temporarily"
    return 1
}

# Function to stop workflows running on a specific runner
stop_workflows_for_runner() {
    local runner_name=$1
    print_info "Stopping workflows running on runner: $runner_name"
    
    # Generate GitHub token to ensure we have auth and repo context
    generate_runner_token
    
    # Get list of in-progress workflow runs
    local running_runs
    running_runs=$(gh run list --status in_progress --json databaseId,id,workflowName,status --limit 100 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        print_error "Failed to fetch running workflows for $GITHUB_OWNER/$GITHUB_REPO"
        return 1
    fi
    
    local run_count
    run_count=$(echo "$running_runs" | jq 'length' 2>/dev/null)
    
    if [ "$run_count" = "0" ] || [ -z "$run_count" ]; then
        print_info "No running workflows found"
        return 0
    fi
    
    # Check if any workflows are running on this specific runner
    local runner_workflows=0
    local stopped_count=0
    
    echo "$running_runs" | jq -r '.[] | "\(.databaseId)|\(.id)|\(.workflowName)"' | while IFS='|' read -r run_id workflow_id workflow_name; do
        if [ -n "$run_id" ] && [ -n "$workflow_id" ]; then
            # Get detailed run info to check which runner it's using
            local run_info
            run_info=$(gh run view "$workflow_id" --json jobs 2>/dev/null)
            
            if [ $? -eq 0 ]; then
                # Check if any job in this run is using the specific runner
                local using_runner
                using_runner=$(echo "$run_info" | jq -r '.jobs[] | select(.runner_name == "'$runner_name'") | .id' 2>/dev/null)
                
                if [ -n "$using_runner" ]; then
                    runner_workflows=$((runner_workflows + 1))
                    print_info "Stopping workflow '$workflow_name' (ID: $workflow_id) running on $runner_name..."
                    
                    # Cancel the workflow run
                    if gh run cancel "$workflow_id" 2>/dev/null; then
                        print_success "Successfully stopped workflow '$workflow_name'"
                        stopped_count=$((stopped_count + 1))
                    else
                        print_warning "Failed to stop workflow '$workflow_name'"
                    fi
                fi
            fi
        fi
    done
    
    if [ "$runner_workflows" -gt 0 ]; then
        print_success "Stopped $stopped_count workflow(s) running on $runner_name"
        
        # Wait a moment for workflows to fully stop
        if [ "$stopped_count" -gt 0 ]; then
            print_info "Waiting for workflows to fully stop..."
            sleep 5
        fi
    else
        print_info "No workflows found running on $runner_name"
    fi
}

# Function to remove/de-register a GitHub runner
remove_runner() {
    local runner_name=$1
    local runner_vm_name="${runner_name}_runner"
    local vmware_vm_name="runner-${runner_name}"
    print_info "Removing GitHub runner: $runner_name"

    # Stop workflows running on this runner first
    stop_workflows_for_runner "$runner_name"

    # Try to find the runner by checking different VM types
    local vm_ip=""
    local vm_hostname=""
    local runner_found=false
    local runner_type=""

    # Check if it's a tart VM (look for the cloned VM with _runner suffix)
    if [ -x "$TART_PATH" ] && "$TART_PATH" list | grep -q "$runner_vm_name"; then
        print_info "Found tart runner VM: $runner_vm_name"
        runner_type="tart"
        vm_ip=$("$TART_PATH" ip "$runner_vm_name" 2>/dev/null)
        if [ $? -eq 0 ] && [ -n "$vm_ip" ] && [ "$vm_ip" != "null" ]; then
            runner_found=true
            print_info "VM IP: $vm_ip"
        else
            print_warning "Tart runner VM '$runner_vm_name' exists but is not running or has no IP"
            # Try to get VM state
            local vm_state=$("$TART_PATH" list | grep "$runner_vm_name" | awk '{print $NF}')
            if [ "$vm_state" = "stopped" ]; then
                print_info "VM is stopped, will delete it directly"
                runner_found="stopped"
            fi
        fi
    # Check if it's a VMware VM
    elif vmware_vm_exists "$vmware_vm_name"; then
        print_info "Found VMware runner VM: $vmware_vm_name"
        runner_type="vmware"
        vm_hostname=$(get_vmware_vm_hostname "$runner_name")

        # Check if VM is running
        local vm_path=$(get_vmware_vm_path "$vmware_vm_name")
        local running_vms
        running_vms=$(ssh "$VMWARE_SSH_HOST" "'$VMWARE_VMRUN_PATH' list" 2>/dev/null)

        if echo "$running_vms" | grep -q "$vm_path"; then
            runner_found=true
            print_info "VM hostname: $vm_hostname"
        else
            print_info "VMware VM exists but is not running, will delete it directly"
            runner_found="stopped"
        fi
    fi

    # If VM is not found, prompt user for manual cleanup
    if [ "$runner_found" = false ]; then
        print_warning "Could not automatically locate runner VM for '$runner_name'"
        print_info "To manually remove the runner from GitHub:"
        print_info "  1. Go to your repository settings"
        print_info "  2. Navigate to Actions > Runners"
        print_info "  3. Find and remove the runner named '$runner_name'"
        return 0
    fi

    # If VM is running, clean up the runner first
    if [ "$runner_found" = true ]; then
        # Determine SSH target based on runner type
        local ssh_target=""
        if [ "$runner_type" = "tart" ]; then
            ssh_target="admin@$vm_ip"
        elif [ "$runner_type" = "vmware" ]; then
            ssh_target="$VMWARE_VM_USER@$vm_hostname"
        fi

        # Test SSH connection with retries
        print_info "Testing SSH connection to $ssh_target..."
        local test_ip="$vm_ip"
        local use_legacy=false
        if [ "$runner_type" = "vmware" ]; then
            test_ip="$vm_hostname"
            use_legacy=true
        fi

        if ! test_ssh_connection_with_retries "$test_ip" "$use_legacy" 2>/dev/null; then
            print_error "SSH connection failed to $ssh_target"
            print_warning "Cannot automatically remove runner. Will proceed to shutdown and delete VM."
        else
            print_success "SSH connection established"

            # Check if runner directory exists (use appropriate SSH command)
            local ssh_cmd="ssh"
            local ssh_opts_ref="SSH_OPTS[@]"
            if [ "$runner_type" = "vmware" ]; then
                ssh_cmd="$LEGACY_SSH_CMD"
                ssh_opts_ref="LEGACY_SSH_OPTS[@]"
            fi

            if $ssh_cmd "${!ssh_opts_ref}" "$ssh_target" "test -d /opt/actions-runner" 2>/dev/null; then
                # Stop the runner service if it's running
                print_info "Stopping runner service..."
                $ssh_cmd "${!ssh_opts_ref}" "$ssh_target" "cd /opt/actions-runner && ./svc.sh stop" 2>/dev/null || print_warning "Service may not be running"

                # Uninstall the service
                print_info "Uninstalling runner service..."
                $ssh_cmd "${!ssh_opts_ref}" "$ssh_target" "cd /opt/actions-runner && ./svc.sh uninstall" 2>/dev/null || print_warning "Service may not be installed"

                # Remove the runner from GitHub
                print_info "Removing runner from GitHub..."
                if $ssh_cmd "${!ssh_opts_ref}" "$ssh_target" "cd /opt/actions-runner && ./config.sh remove --token '$RUNNER_TOKEN'" 2>/dev/null; then
                    print_success "Runner removed from GitHub successfully"
                else
                    print_warning "Failed to remove runner from GitHub automatically"
                    print_info "The runner may have already been removed or the token may be invalid"
                fi

                # Clean up the installation directory
                print_info "Cleaning up installation directory..."
                $ssh_cmd "${!ssh_opts_ref}" "$ssh_target" "sudo rm -rf /opt/actions-runner" 2>/dev/null || print_warning "Failed to clean up installation directory"
            else
                print_warning "GitHub runner not found on VM. It may have already been removed."
            fi
        fi
    fi

    # Shutdown and delete the VM based on type
    if [ "$runner_type" = "tart" ]; then
        print_info "Shutting down runner VM: $runner_vm_name"
        "$TART_PATH" stop "$runner_vm_name" 2>/dev/null || print_warning "VM may already be stopped"

        print_info "Deleting runner VM: $runner_vm_name"
        if "$TART_PATH" delete "$runner_vm_name" 2>/dev/null; then
            print_success "Runner VM '$runner_vm_name' deleted successfully"
        else
            print_error "Failed to delete runner VM '$runner_vm_name'"
            print_info "You may need to delete it manually: tart delete $runner_vm_name"
        fi
    elif [ "$runner_type" = "vmware" ]; then
        local vm_path=$(get_vmware_vm_path "$vmware_vm_name")

        print_info "Shutting down VMware VM: $vmware_vm_name"
        ssh "$VMWARE_SSH_HOST" "'$VMWARE_VMRUN_PATH' stop '$vm_path' hard" 2>/dev/null || print_warning "VM may already be stopped"
        sleep 2

        print_info "Deleting VMware VM: $vmware_vm_name"
        if ssh "$VMWARE_SSH_HOST" "'$VMWARE_VMRUN_PATH' deleteVM '$vm_path'" 2>/dev/null; then
            print_success "VMware VM '$vmware_vm_name' deleted successfully"
        else
            # Try alternative: just remove the directory
            print_warning "vmrun deleteVM failed, trying direct directory removal..."
            if ssh "$VMWARE_SSH_HOST" "rm -rf '${VMWARE_BASE_DIR}/${vmware_vm_name}.vmwarevm'"; then
                print_success "Removed VMware VM directory: $vmware_vm_name"
            else
                print_error "Failed to delete VMware VM: $vmware_vm_name"
                print_info "You may need to delete it manually on $VMWARE_SSH_HOST"
            fi
        fi
    fi

    print_success "Runner '$runner_name' removal completed"
    print_info "The base VM remains available for future runner creation"
}

# Function to validate runner name
validate_runner_name() {
    local runner_name=$1
    local runner_type=$2
    
    if [ -z "$runner_name" ]; then
        print_error "Runner name is required for $runner_type"
        usage
        exit 1
    fi
    
    # Basic validation - can be enhanced
    if [[ ! "$runner_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Invalid runner name: $runner_name. Use only letters, numbers, hyphens, and underscores."
        exit 1
    fi
}

# Function to list registered runners for the repository
list_runners() {
    print_info "Listing GitHub runners for repository..."
    
    # Generate token to ensure we have auth and repo context
    generate_runner_token
    
    print_info "Repository: $GITHUB_OWNER/$GITHUB_REPO"
    print_info "Fetching registered runners..."
    
    # Use gh CLI to list runners
    local runners_json
    runners_json=$(gh api repos/$GITHUB_OWNER/$GITHUB_REPO/actions/runners --jq '.runners' 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        print_error "Failed to fetch runners for $GITHUB_OWNER/$GITHUB_REPO. Check your permissions."
        print_info "Make sure you have admin access to the repository or 'Manage runners' permission."
        return 1
    fi
    
    # Parse and display runner information
    local runner_count
    runner_count=$(echo "$runners_json" | jq 'length' 2>/dev/null)
    
    if [ "$runner_count" = "0" ] || [ -z "$runner_count" ]; then
        print_warning "No runners found for repository $GITHUB_OWNER/$GITHUB_REPO"
        return 0
    fi
    
    print_success "Found $runner_count registered runner(s):"
    echo
    echo "GitHub Repository: $GITHUB_OWNER/$GITHUB_REPO"
    echo "=================================================================================="
    printf "%-20s %-15s %-10s %-20s %s\n" "NAME" "STATUS" "BUSY" "OS" "LABELS"
    echo "=================================================================================="
    
    # Display each runner
    echo "$runners_json" | jq -r '.[] | "\(.name)|\(.status)|\(.busy)|\(.os)|\(.labels | map(.name) | join(","))"' | while IFS='|' read -r name status busy os labels; do
        printf "%-20s %-15s %-10s %-20s %s\n" "$name" "$status" "$busy" "$os" "$labels"
    done
    
    echo
    print_info "Use '$0 -remove <runner_name>' to remove a specific runner"
}

# Main script logic
main() {
    # Check for help flag first (before dependency check)
    for arg in "$@"; do
        if [[ "$arg" == "-h" || "$arg" == "--help" ]]; then
            usage
            exit 0
        fi
    done
    
    # Check dependencies
    check_dependencies
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -tart)
                RUNNER_TYPE="tart"
                shift
                if [[ $# -gt 0 && ! $1 =~ ^- ]]; then
                    RUNNER_NAME="$1"
                    shift
                fi
                ;;
            -lima)
                RUNNER_TYPE="lima"
                shift
                if [[ $# -gt 0 && ! $1 =~ ^- ]]; then
                    RUNNER_NAME="$1"
                    shift
                fi
                ;;
            -vmware)
                RUNNER_TYPE="vmware"
                shift
                if [[ $# -gt 0 && ! $1 =~ ^- ]]; then
                    RUNNER_NAME="$1"
                    shift
                fi
                ;;
            -r)
                RUNNER_NAME="$2"
                shift 2
                ;;
            -ssh)
                SSH_HOST="$2"
                shift 2
                ;;
            -start-all)
                ACTION="start-all"
                shift
                ;;
            -remove-all)
                ACTION="remove-all"
                shift
                ;;
            -remove)
                ACTION="remove"
                RUNNER_NAME="$2"
                shift 2
                ;;
            -cancel-workflows)
                ACTION="cancel-workflows"
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -owner)
                GITHUB_OWNER="$2"
                shift 2
                ;;
            -repo)
                GITHUB_REPO="$2"
                shift 2
                ;;
            -list)
                ACTION="list"
                shift
                ;;
            -debug)
                DEBUG_MODE="true"
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
    
    # Validate arguments
    if [ -z "$ACTION" ] && [ -z "$RUNNER_TYPE" ]; then
        print_error "No action specified"
        usage
        exit 1
    fi
    
    if [ -n "$RUNNER_TYPE" ] && [ -z "$RUNNER_NAME" ]; then
        print_error "Runner name is required when specifying runner type"
        usage
        exit 1
    fi
    
    # Execute action
    case $ACTION in
        "start-all")
            start_all_runners
            ;;
        "remove-all")
            remove_all_runners
            ;;
        "remove")
            if [ -z "$RUNNER_NAME" ]; then
                print_error "Runner name is required for remove operation"
                usage
                exit 1
            fi
            generate_runner_token
            remove_runner "$RUNNER_NAME"
            ;;
        "cancel-workflows")
            stop_all_workflows
            ;;
        "list")
            list_runners
            ;;
        "")
            # Start specific runner
            validate_runner_name "$RUNNER_NAME" "$RUNNER_TYPE"
            generate_runner_token
            
            case $RUNNER_TYPE in
                "tart")
                    start_tart_runner "$RUNNER_NAME"
                    ;;
                "lima")
                    start_lima_runner "$RUNNER_NAME"
                    ;;
                "vmware")
                    start_vmware_runner "$RUNNER_NAME"
                    ;;
                *)
                    print_error "Unknown runner type: $RUNNER_TYPE"
                    exit 1
                    ;;
            esac
            ;;
    esac
    
    print_success "Operation completed"
}

# Run main function with all arguments
main "$@" 