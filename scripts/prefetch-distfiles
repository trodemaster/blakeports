#!/bin/bash
# Script to pre-fetch distfiles for ports and transfer them to legacy VMs
# This solves the circular dependency: curl needs distfiles, but system curl 
# on legacy systems cannot download from modern HTTPS servers.
#
# Usage: prefetch-distfiles <vm_ip> <vm_username> <ssh_key_path> [port_list]
#
# Distfiles are downloaded in the container (which has modern curl) and then
# SCPed to the legacy VM's MacPorts distfiles directory, where port install
# will find them locally and skip the download phase.
#
# Default port list for curl +ssl bootstrap:
# curl zlib openssl3 curl-ca-bundle pkgconfig libiconv perl5.34 gperf
# db48 gdbm gettext gettext-runtime gettext-tools-libs readline 
# libtextstyle ncurses xz unzip
#
# Extract dependencies: xz, unzip (pre-built tools used during extraction)

set -euo pipefail
IFS=$'\n\t'

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored messages
info() {
    echo -e "${GREEN}ℹ️  $*${NC}"
}

warn() {
    echo -e "${YELLOW}⚠️  $*${NC}"
}

error() {
    echo -e "${RED}❌ $*${NC}"
}

header() {
    echo -e "${BLUE}════════════════════════════════════════${NC}"
    echo -e "${BLUE}$*${NC}"
    echo -e "${BLUE}════════════════════════════════════════${NC}"
}

# Distfiles list for curl +ssl -brotli -http2 -idn -psl -zstd bootstrap
# Format: "port:distfile" - Files are copied from /config/distfiles-cache/
# which is populated by running ./scripts/cache-distfiles on the host
declare -a DISTFILES=(
    # curl and dependencies
    "curl:curl-8.13.0.tar.xz"
    "zlib:zlib-1.3.1.tar.xz"
    "openssl3:openssl-3.5.4.tar.gz"
    "pkgconfig:pkg-config-0.29.2.tar.gz"
    
    # libiconv and dependencies
    "libiconv:libiconv-1.17.tar.gz"
    "gperf:gperf-3.3.tar.gz"
    
    # Perl and dependencies
    "perl5.34:perl-5.34.3.tar.xz"
    "db48:db-4.8.30.tar.gz"
    "gdbm:gdbm-1.26.tar.gz"
    
    # gettext and dependencies
    "gettext:gettext-0.22.5.tar.gz"
    "ncurses:ncurses-6.5.tar.gz"
    
    # readline
    "readline:readline-8.2.tar.gz"
    
    # Tools
    "xz:xz-5.8.1.tar.bz2"
    "unzip:unzip60.tar.gz"
)

# Parse arguments
if [[ $# -lt 3 ]]; then
    error "Usage: $0 <vm_ip> <vm_username> <ssh_key_path> [port_list_file]"
    echo "Example: $0 192.168.234.110 blake /config/ssh_keys/oldmac"
    exit 1
fi

VM_IP="$1"
VM_USERNAME="$2"
SSH_KEY_PATH="$3"
MACPORTS_PREFIX="/opt/local"
DISTFILES_DIR="/opt/local/var/macports/distfiles"
TEMP_DIR="/tmp/prefetch-distfiles-$$"

# Cleanup on exit
cleanup() {
    if [ -d "$TEMP_DIR" ]; then
        info "Cleaning up temporary directory..."
        rm -rf "$TEMP_DIR"
    fi
}
trap cleanup EXIT

header "Prefetching distfiles for curl bootstrap"
info "VM: $VM_USERNAME@$VM_IP"
info "Temp directory: $TEMP_DIR"

# Create temporary directory
mkdir -p "$TEMP_DIR"
cd "$TEMP_DIR"

# Phase 1: Copy distfiles from mounted cache
header "Phase 1: Copying distfiles from cache"

CACHE_DIR="/config/distfiles-cache"

# Verify cache directory is mounted
if [ ! -d "$CACHE_DIR" ]; then
    error "Cache directory not found: $CACHE_DIR"
    error "Run './scripts/cache-distfiles' on the host to populate the cache first"
    exit 1
fi

info "Cache directory found: $CACHE_DIR"

total_files=${#DISTFILES[@]}
copied_count=0
failed_files=()

for entry in "${DISTFILES[@]}"; do
    port_name=$(echo "$entry" | cut -d: -f1)
    distfile=$(echo "$entry" | cut -d: -f2)
    
    echo ""
    info "[$((++copied_count))/$total_files] Copying $port_name: $distfile"
    
    # Create port-specific directory
    mkdir -p "$port_name"
    
    # Try to copy from cache
    cache_file="$CACHE_DIR/$port_name/$distfile"
    
    # Handle ports that share distfile directories (gettext family)
    if [ ! -f "$cache_file" ]; then
        case "$port_name" in
            gettext-runtime|gettext-tools-libs|libtextstyle)
                cache_file="$CACHE_DIR/gettext/$distfile"
                ;;
        esac
    fi
    
    if [ -f "$cache_file" ]; then
        cp "$cache_file" "$port_name/"
        info "✅ Copied: $distfile ($(du -h "$port_name/$distfile" | cut -f1))"
    else
        error "File not found in cache: $cache_file"
        failed_files+=("$port_name:$distfile")
    fi
done

# Check for failures
if [ ${#failed_files[@]} -gt 0 ]; then
    error "Failed to copy ${#failed_files[@]} files from cache:"
    for failed in "${failed_files[@]}"; do
        echo "  - $failed"
    done
    error "Run './scripts/cache-distfiles' on the host to populate the cache"
    exit 1
fi

info "✅ All distfiles copied from cache successfully"

# Phase 2: Transfer distfiles to legacy VM
header "Phase 2: Transferring distfiles to legacy VM"

info "Creating temporary transfer directory on VM..."
ssh -i "$SSH_KEY_PATH" \
    -o StrictHostKeyChecking=no \
    -o UserKnownHostsFile=/dev/null \
    -o HostKeyAlgorithms=+ssh-rsa \
    -o PubkeyAcceptedKeyTypes=+ssh-rsa \
    "$VM_USERNAME@$VM_IP" bash <<'VMEOF'
set -e
# Create temp directory for transfers (no sudo needed)
mkdir -p /tmp/prefetch-distfiles
# Create distfiles structure with sudo
sudo mkdir -p /opt/local/var/macports/distfiles/{curl,zlib,openssl3,pkgconfig,libiconv,gperf,perl5.34,db48,gdbm,gettext,ncurses,readline,xz,unzip}
echo "✅ Directories created"
VMEOF

# Transfer each distfile via SCP to /tmp first
transferred_count=0
cd "$TEMP_DIR"

for entry in "${DISTFILES[@]}"; do
    port_name=$(echo "$entry" | cut -d: -f1)
    distfile=$(echo "$entry" | cut -d: -f2)
    
    if [ ! -f "$port_name/$distfile" ]; then
        warn "Skipping $port_name/$distfile (not found locally, may have failed to download)"
        continue
    fi
    
    info "[$((++transferred_count))/$total_files] Transferring $port_name/$distfile..."
    
    # SCP to /tmp first (no sudo needed)
    scp -i "$SSH_KEY_PATH" \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o HostKeyAlgorithms=+ssh-rsa \
        -o PubkeyAcceptedKeyTypes=+ssh-rsa \
        "$port_name/$distfile" \
        "$VM_USERNAME@$VM_IP:/tmp/prefetch-distfiles/" || {
        error "Failed to transfer $port_name/$distfile"
        exit 1
    }
    
    # Move to final location with sudo and set permissions
    ssh -i "$SSH_KEY_PATH" \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o HostKeyAlgorithms=+ssh-rsa \
        -o PubkeyAcceptedKeyTypes=+ssh-rsa \
        "$VM_USERNAME@$VM_IP" "sudo mv /tmp/prefetch-distfiles/$distfile $DISTFILES_DIR/$port_name/ && sudo chmod 644 $DISTFILES_DIR/$port_name/$distfile" || {
        error "Failed to move $port_name/$distfile to final location"
        exit 1
    }
done

info "✅ All distfiles transferred successfully"

# Phase 3: Verify transfer and cleanup
header "Phase 3: Verifying distfiles on VM"

info "Checking distfiles directory on VM..."
ssh -i "$SSH_KEY_PATH" \
    -o StrictHostKeyChecking=no \
    -o UserKnownHostsFile=/dev/null \
    -o HostKeyAlgorithms=+ssh-rsa \
    -o PubkeyAcceptedKeyTypes=+ssh-rsa \
    "$VM_USERNAME@$VM_IP" bash <<'VMEOF'
set -e
echo "Distfiles directory contents:"
du -sh /opt/local/var/macports/distfiles/*/ 2>/dev/null || echo "No subdirectories yet"
echo ""
echo "Total distfiles size:"
du -sh /opt/local/var/macports/distfiles/
echo ""
echo "Total files:"
find /opt/local/var/macports/distfiles -type f | wc -l
echo ""
echo "Permissions check (should be readable by all):"
ls -la /opt/local/var/macports/distfiles/curl/ 2>/dev/null | head -5 || echo "curl directory not found"
echo ""
echo "Cleaning up temp directory..."
rm -rf /tmp/prefetch-distfiles
VMEOF

header "✅ Distfile prefetch complete!"
info "Distfiles are now available locally on the VM"
info "port install curl -brotli -http2 -idn -psl -zstd +ssl will use local files"

exit 0
